<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body { margin: 0; padding: 0; }
        poline-picker {
            width: 100%;
            height: 100%;
            display: block;
            --poline-picker-line-color: #333;
            --poline-picker-bg-color: #fff;
        }
    </style>
</head>
<body>
    <poline-picker id="picker" interactive allow-add-points></poline-picker>
    
    <script type="module">
        import { Poline, PolinePicker, positionFunctions } from 'https://unpkg.com/poline/dist/picker.mjs';
        
        const picker = document.getElementById('picker');
        
        // Store current poline config for steps updates
        let currentConfig = {
            anchorColors: [[0, 0.8, 0.6], [180, 0.7, 0.4]],
            numPoints: 3,
            invertedLightness: false,
            closedLoop: false,
            positionFunctionX: 'linearPosition',
            positionFunctionY: 'linearPosition', 
            positionFunctionZ: 'linearPosition'
        };
        
        // Function to create poline with current config
        const createPolineWithConfig = (config) => {
            const polineOptions = {
                anchorColors: config.anchorColors,
                numPoints: config.numPoints,
                invertedLightness: config.invertedLightness,
                closedLoop: config.closedLoop
            };

            // Set position functions using the imported positionFunctions
            if (config.positionFunctionX && positionFunctions[config.positionFunctionX]) {
                polineOptions.positionFunctionX = positionFunctions[config.positionFunctionX];
            }
            if (config.positionFunctionY && positionFunctions[config.positionFunctionY]) {
                polineOptions.positionFunctionY = positionFunctions[config.positionFunctionY];
            }
            if (config.positionFunctionZ && positionFunctions[config.positionFunctionZ]) {
                polineOptions.positionFunctionZ = positionFunctions[config.positionFunctionZ];
            }

            return new Poline(polineOptions);
        };

        // Default poline using currentConfig
        const poline = createPolineWithConfig(currentConfig);
        picker.setPoline(poline);
        
        // Send initial colors
        setTimeout(() => {
            const initialColors = [...poline.colors];
            console.log('Sending initial colors:', initialColors);
            window.parent.postMessage({ type: 'poline-colors-update', polineColors: initialColors }, '*');
        }, 100);
        
        // Listen for changes and update the poline palette display
        picker.addEventListener('poline-change', (event) => {
            const { poline } = event.detail;
            // Send ALL colors from the poline picker - includes all nodes and generated colors
            const allColors = [...poline.colors]; // This includes all anchor + intermediate colors
            console.log('Sending colors from iframe:', allColors);
            window.parent.postMessage({ type: 'poline-colors-update', polineColors: allColors }, '*');
        });
        
        // Listen for updates from parent
        window.addEventListener('message', (event) => {
            if (event.data.type === 'update-poline') {
                const newPoline = new Poline(event.data.config);
                currentConfig = event.data.config;
                picker.setPoline(newPoline);
            } else if (event.data.type === 'update-steps') {
                // Update number of intermediate points while keeping anchor colors fixed
                // Steps = total colors including anchors, so intermediate points = steps - 2
                const newNumPoints = Math.max(0, event.data.steps - 2);
                
                // Keep the same anchor colors, only change intermediate points
                currentConfig.numPoints = newNumPoints;
                
                const updatedPoline = createPolineWithConfig(currentConfig);
                picker.setPoline(updatedPoline);
                
                // Send updated colors immediately
                const polineColors = [...updatedPoline.colors];
                window.parent.postMessage({ type: 'poline-colors-update', polineColors }, '*');
            } else if (event.data.type === 'update-config') {
                // Update specific config properties
                Object.assign(currentConfig, event.data.config);
                
                const updatedPoline = createPolineWithConfig(currentConfig);
                picker.setPoline(updatedPoline);
                
                // Send updated colors immediately
                const polineColors = [...updatedPoline.colors];
                window.parent.postMessage({ type: 'poline-colors-update', polineColors }, '*');
            } else if (event.data.type === 'reset-to-defaults') {
                // COMPLETE RESET - Reset to default configuration and clear all added nodes
                currentConfig = {
                    anchorColors: [[0, 0.8, 0.6], [180, 0.7, 0.4]],
                    numPoints: 3, // 5 steps - 2 anchors = 3 intermediate points
                    invertedLightness: false,
                    closedLoop: false,
                    positionFunctionX: 'linearPosition',
                    positionFunctionY: 'linearPosition',
                    positionFunctionZ: 'linearPosition'
                };
                
                // Create completely fresh poline to reset all nodes
                const defaultPoline = createPolineWithConfig(currentConfig);
                
                // Force complete reset of the picker - this clears all user-added nodes
                picker.setPoline(defaultPoline);
                
                // Send ALL colors immediately (should be exactly 5 default colors)
                const allColors = [...defaultPoline.colors];
                window.parent.postMessage({ type: 'poline-colors-update', polineColors: allColors }, '*');
            } else if (event.data.type === 'reset-to-ai-colors') {
                // Use FIRST and LAST AI colors as anchor points only
                const aiColors = event.data.colors;
                let firstColor, lastColor;
                
                if (aiColors.length >= 2) {
                    // Convert first color to HSL
                    const firstHex = aiColors[0].hex;
                    const r1 = parseInt(firstHex.slice(1, 3), 16) / 255;
                    const g1 = parseInt(firstHex.slice(3, 5), 16) / 255;
                    const b1 = parseInt(firstHex.slice(5, 7), 16) / 255;
                    
                    const max1 = Math.max(r1, g1, b1);
                    const min1 = Math.min(r1, g1, b1);
                    let h1, s1, l1 = (max1 + min1) / 2;
                    
                    if (max1 === min1) {
                        h1 = s1 = 0;
                    } else {
                        const d1 = max1 - min1;
                        s1 = l1 > 0.5 ? d1 / (2 - max1 - min1) : d1 / (max1 + min1);
                        switch (max1) {
                            case r1: h1 = (g1 - b1) / d1 + (g1 < b1 ? 6 : 0); break;
                            case g1: h1 = (b1 - r1) / d1 + 2; break;
                            case b1: h1 = (r1 - g1) / d1 + 4; break;
                        }
                        h1 /= 6;
                    }
                    firstColor = [h1 * 360, s1, l1];
                    
                    // Convert last color to HSL
                    const lastHex = aiColors[aiColors.length - 1].hex;
                    const r2 = parseInt(lastHex.slice(1, 3), 16) / 255;
                    const g2 = parseInt(lastHex.slice(3, 5), 16) / 255;
                    const b2 = parseInt(lastHex.slice(5, 7), 16) / 255;
                    
                    const max2 = Math.max(r2, g2, b2);
                    const min2 = Math.min(r2, g2, b2);
                    let h2, s2, l2 = (max2 + min2) / 2;
                    
                    if (max2 === min2) {
                        h2 = s2 = 0;
                    } else {
                        const d2 = max2 - min2;
                        s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
                        switch (max2) {
                            case r2: h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0); break;
                            case g2: h2 = (b2 - r2) / d2 + 2; break;
                            case b2: h2 = (r2 - g2) / d2 + 4; break;
                        }
                        h2 /= 6;
                    }
                    lastColor = [h2 * 360, s2, l2];
                } else {
                    // Fallback to defaults
                    firstColor = [0, 0.8, 0.6];
                    lastColor = [180, 0.7, 0.4];
                }
                
                // Reset config with first/last as anchors, linear functions, 3 intermediate points
                currentConfig = {
                    anchorColors: [firstColor, lastColor],
                    numPoints: 3, // 5 total colors (2 anchors + 3 intermediate)
                    invertedLightness: false,
                    closedLoop: false,
                    positionFunctionX: 'linearPosition',
                    positionFunctionY: 'linearPosition',
                    positionFunctionZ: 'linearPosition'
                };
                
                const resetPoline = createPolineWithConfig(currentConfig);
                picker.setPoline(resetPoline);
                
                // Send updated colors immediately
                const resetColors = [...resetPoline.colors];
                window.parent.postMessage({ type: 'poline-colors-update', polineColors: resetColors }, '*');
            } else if (event.data.type === 'set-ai-colors') {
                // Convert AI hex colors to HSL for poline
                const anchorColors = event.data.colors.map(color => {
                    const r = parseInt(color.hex.slice(1, 3), 16) / 255;
                    const g = parseInt(color.hex.slice(3, 5), 16) / 255;
                    const b = parseInt(color.hex.slice(5, 7), 16) / 255;
                    
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    let h, s, l = (max + min) / 2;
                    
                    if (max === min) {
                        h = s = 0;
                    } else {
                        const d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                        switch (max) {
                            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                            case g: h = (b - r) / d + 2; break;
                            case b: h = (r - g) / d + 4; break;
                        }
                        h /= 6;
                    }
                    
                    return [h * 360, s, l];
                });
                
                // Use first and middle colors as anchor points
                const numColors = event.data.colors.length;
                let selectedAnchors;
                
                if (numColors >= 3) {
                    const middleIndex = Math.floor(numColors / 2);
                    selectedAnchors = [anchorColors[0], anchorColors[middleIndex]];
                } else if (numColors === 2) {
                    selectedAnchors = [anchorColors[0], anchorColors[1]];
                } else {
                    selectedAnchors = [anchorColors[0], [anchorColors[0][0] + 180, anchorColors[0][1], anchorColors[0][2]]];
                }
                
                // Update current config with AI colors
                // Keep the anchor colors fixed and set intermediate points
                currentConfig = {
                    anchorColors: selectedAnchors,
                    numPoints: Math.max(0, numColors - 2)
                };
                
                const aiPoline = new Poline(currentConfig);
                picker.setPoline(aiPoline);
            } else if (event.data.type === 'request-colors') {
                // Send current colors to parent
                const poline = picker.getPoline();
                const polineColors = [...poline.colors]; // Raw HSL array [h, s, l]
                window.parent.postMessage({ type: 'poline-colors-update', polineColors }, '*');
            }
        });
    </script>
</body>
</html>
